<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width,
      user-scalable=no, initial-scale=1, maximum-scale=1, user-scalable=0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <style type="text/css">
    body { margin: 0; padding: 0; background: #000;}
    canvas { display: block; margin: 0 auto; background: #fff; }
  </style>

  <script src="/socket.io/socket.io.js"></script>
  <script src="//davidshimjs.github.com/qrcodejs/qrcode.min.js"></script>
  <script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>

</head>

<body>

<canvas> </canvas>
<script>

window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          window.oRequestAnimationFrame      ||
          window.msRequestAnimationFrame     ||
          function( callback ){
            window.setTimeout(callback, 1000 / 60);
          };
})();

// namespace our game
var POP = {

    entities: [],
    // set up some initial values
    WIDTH: 320,
    HEIGHT:  480,
    // we'll set the rest of these
    // in the init function
    RATIO:  null,
    currentWidth:  null,
    currentHeight:  null,
    canvas: null,
    ctx:  null,

    init: function() {

        // the proportion of width to height
        POP.RATIO = POP.WIDTH / POP.HEIGHT;
        // these will change when the screen is resized
        POP.currentWidth = POP.WIDTH;
        POP.currentHeight = POP.HEIGHT;
        // this is our canvas element
        POP.canvas = document.getElementsByTagName('canvas')[0];
        // setting this is important
        // otherwise the browser will
        // default to 320 x 200
        POP.canvas.width = POP.WIDTH;
        POP.canvas.height = POP.HEIGHT;
        // the canvas context enables us to
        // interact with the canvas api
        POP.ctx = POP.canvas.getContext('2d');

        // we're ready to resize
        POP.resize();

        // include this at the end of POP.init function
        POP.Draw.clear();
        POP.Draw.rect(120,120,150,150, 'green');
        POP.Draw.circle(100, 100, 50, 'rgba(255,0,0,0.5)');
        POP.Draw.text('Hello World', 100, 100, 10, '#000');

        // listen for clicks
        window.addEventListener('click', function(e) {
          console.log('clicked somewhere1');
            e.preventDefault();
            POP.Input.set(e);
        }, false);

        // listen for touches
        window.addEventListener('touchstart', function(e) {
          console.log('clicked somewhere1');
            e.preventDefault();
            // the event object has an array
            // named touches; we just want
            // the first touch
            POP.Input.set(e.touches[0]);
        }, false);
        window.addEventListener('touchmove', function(e) {
            // we're not interested in this,
            // but prevent default behaviour
            // so the screen doesn't scroll
            // or zoom
            e.preventDefault();
        }, false);
        window.addEventListener('touchend', function(e) {
          console.log('clicked somewhere1');
            // as above
            e.preventDefault();
        }, false);

        POP.entities.push(new POP.Bubble());

        POP.loop();

    },

        // this is where all entities will be moved
    // and checked for collisions, etc.
    update: function() {
      console.log('update');
        var i, checkCollision = false; ;

        if (POP.Input.tapped) {
          console.log('clicked somewhere2');
            POP.entities.push(new POP.Touch(POP.Input.x, POP.Input.y));
            POP.Input.tapped = false;
            checkCollision = true;
        }

        // cycle through all entities and update as necessary
        for (i = 0; i < POP.entities.length; i += 1) {
            POP.entities[i].update();

            if (POP.entities[i].type === 'bubble' && checkCollision) {
                hit = POP.collides(POP.entities[i],
                        {x: POP.Input.x, y: POP.Input.y, r: 7});
                              POP.entities[i].remove = hit;
                          }


            // delete from array if remove property
            // flag is set to true
            if (POP.entities[i].remove) {
                POP.entities.splice(i, 1);
            }
        }

    },

    // this is where we draw all the entities
    // POP.render function
    render: function() {

        var i;

       POP.Draw.rect(0, 0, POP.WIDTH, POP.HEIGHT, '#036');

        // cycle through all entities and render to canvas
        for (i = 0; i < POP.entities.length; i += 1) {
            POP.entities[i].render();
        }

    },

    // the actual loop
    // requests animation frame,
    // then proceeds to update
    // and render
    loop: function() {

        requestAnimFrame( POP.loop );

        POP.update();
        POP.render();
    },

    resize: function() {//

        POP.currentHeight = window.innerHeight;
        POP.currentWidth = POP.currentHeight * POP.RATIO;
        if (POP.android || POP.ios) {
            document.body.style.height = (window.innerHeight + 50) + 'px';
        }
        POP.canvas.style.width = POP.currentWidth + 'px';
        POP.canvas.style.height = POP.currentHeight + 'px';
        window.setTimeout(function() {
                window.scrollTo(0,1);
        }, 1);
    }

};

POP.Draw = {

    clear: function() {
        POP.ctx.clearRect(0, 0, POP.WIDTH, POP.HEIGHT);
    },

    rect: function(x, y, w, h, col) {
        POP.ctx.fillStyle = col;
        POP.ctx.fillRect(x, y, w, h);
    },

    circle: function(x, y, r, col) {
        POP.ctx.fillStyle = col;
        POP.ctx.beginPath();
        POP.ctx.arc(x + 5, y + 5, r, 0,  Math.PI * 2, true);
        POP.ctx.closePath();
        POP.ctx.fill();
    },

    text: function(string, x, y, size, col) {
        POP.ctx.font = 'bold '+size+'px Monospace';
        POP.ctx.fillStyle = col;
        POP.ctx.fillText(string, x, y);
    }

};

POP.Input = {

    x: 0,
    y: 0,
    tapped :false,

    set: function(data) {
      var offsetTop = POP.canvas.offsetTop,
          offsetLeft = POP.canvas.offsetLeft;
          scale = POP.currentWidth / POP.WIDTH;

      this.x = ( data.pageX - offsetLeft ) / scale;
      this.y = ( data.pageY - offsetTop ) / scale;

      POP.Draw.circle(this.x, this.y, 10, 'red');
    }

};
POP.Bubble = function() {

    this.type = 'bubble';
    this.x = 100;
    this.r = 5;                // the radius of the bubble
    this.y = POP.HEIGHT + 100; // make sure it starts off screen
    this.remove = false;

    this.update = function() {

        // move up the screen by 1 pixel
        this.y -= 1;

        // if off screen, flag for removal
        if (this.y < -10) {
            this.remove = true;
        }

    };

    this.render = function() {

        POP.Draw.circle(this.x, this.y, this.r, 'rgba(255,255,255,1)');
    };

};

POP.collides = function(a, b) {

        var distance_squared = ( ((a.x - b.x) * (a.x - b.x)) +
                                ((a.y - b.y) * (a.y - b.y)));

        var radii_squared = (a.r + b.r) * (a.r + b.r);

        if (distance_squared < radii_squared) {
            return true;
        } else {
            return false;
        }
};

POP.Touch = function(x, y) {
    console.log('new touch')

    this.type = 'touch';    // we'll need this later
    this.x = x;             // the x coordinate
    this.y = y;             // the y coordinate
    this.r = 5;             // the radius
    this.opacity = 1;       // initial opacity; the dot will fade out
    this.fade = 0.05;       // amount by which to fade on each game tick
    this.remove = false;    // flag for removing this entity. POP.update
                            // will take care of this
    this.update = function() {
        // reduce the opacity accordingly
        this.opacity -= this.fade;
        // if opacity if 0 or less, flag for removal
        this.remove = (this.opacity < 0) ? true : false;
    };

    this.render = function() {
        POP.Draw.circle(this.x, this.y, this.r, 'rgba(255,0,0,'+this.opacity+')');
    };

};

window.addEventListener('load', POP.init, false);
window.addEventListener('resize', POP.resize, false);
</script>

</body>
</html>

<!DOCTYPE html>
<!--
<html>
  <head>
    <title> Smartphone Controller </title>
  	<script src="/socket.io/socket.io.js"></script>
    <script src="//davidshimjs.github.com/qrcodejs/qrcode.min.js"></script>
    <script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>
  </head>

  <body>
    <p> CONTROLLER </p>
    <button onclick='sendLeftCommand();' class='load-image'> GO LEFT </button>
    <button onclick='sendRightCommand();' class='load-image'> GO RIGHT </button>

    <script>
    var io = io.connect();

    if (window.location.href.indexOf('?id=') > 0) {
      var game_ID = window.location.href.split('?id=')[1];

      io.emit('controller_connect', game_ID);
      io.on('controller_connected', function(data) {
        console.log("Connected successfully to the game, " + game_ID);
      });

      function sendRightCommand() {io.emit("move_right", game_ID);}
      function sendLeftCommand() {io.emit("move_left", game_ID);}
    } else {
      console.log("No game ID sent")
    }
      </script>
  </body>
</html>

-->
